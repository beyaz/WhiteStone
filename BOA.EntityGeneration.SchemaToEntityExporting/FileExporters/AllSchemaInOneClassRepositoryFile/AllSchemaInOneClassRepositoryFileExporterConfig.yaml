NamingPattern:
  SchemaName: '?'
  EntityNamespace: '?'
  RepositoryNamespace: '?'
  UsingLines: using System;|
    using System.Data;|
    using System.Data.SqlClient;|
    using System.Collections.Generic;|
    using $(EntityNamespace);|
    using $(RepositoryNamespace).Shared;|
    using IUnitOfWork = BOA.Card.Core.UOW.IUnitOfWork;|
    using State = BOA.Card.Core.UOW.State;
  NamespaceName: BOA.Business.Kernel.Card.$(SchemaName).Repository
  ClassName: $(SchemaName)Repository
  ExtraAssemblyReferences: <Reference Include="BOA.Card.Core"><HintPath>D:\BOA\Server\bin\BOA.Card.Core.dll</HintPath></Reference>
DefaultValuesForInsertMethod:
  contractInstanceName:
  contractInstancePropertyName:  
  ROW_GUID: $(contractInstanceName).$(contractInstancePropertyName) = Guid.NewGuid().ToString().ToUpper(new System.Globalization.CultureInfo("en-US", false));
  INSERT_DATE: $(contractInstanceName).$(contractInstancePropertyName) = DateTime.Now;
  INSERT_USER_ID: $(contractInstanceName).$(contractInstancePropertyName) = BOA.Card.Core.Identity.GetIdentity().Name;
  'string:INSERT_TOKEN_ID': $(contractInstanceName).$(contractInstancePropertyName) = "0";
  'decimal:INSERT_TOKEN_ID': $(contractInstanceName).$(contractInstancePropertyName) = 0;
DefaultValuesForUpdateByKeyMethod:
  contractInstanceName:
  contractInstancePropertyName:  
  UPDATE_DATE: $(contractInstanceName).$(contractInstancePropertyName) = DateTime.Now;
  UPDATE_USER_ID: $(contractInstanceName).$(contractInstancePropertyName) = BOA.Card.Core.Identity.GetIdentity().Name;
  'string:UPDATE_TOKEN_ID': $(contractInstanceName).$(contractInstancePropertyName) = "0";
  'decimal:UPDATE_TOKEN_ID': $(contractInstanceName).$(contractInstancePropertyName) = 0;
ExcludedColumnNamesWhenInsertOperation:
  - UPDATE_DATE
  - UPDATE_USER_ID
  - UPDATE_TOKEN_ID
  - UpdateUserName
  - UpdateHostName
  - UpdateHostIP
  - UpdateSystemDate
EmbeddedCodes: |
  /// <summary>
  ///     The unit of work SQL utility
  /// </summary>
  static class UnitOfWorkSqlUtil
  {
      #region Public Methods
      /// <summary>
      ///     Executes the non query.
      /// </summary>
      public static int ExecuteNonQuery(this IUnitOfWork unitOfWork, string methodFullPath, SqlInfo sqlInfo)
      {
          var localConnection = false;
  
          var command = InitializeCommand(unitOfWork, sqlInfo.CommandText, ref localConnection);
  
          AddParameters(command, sqlInfo);
  
          var returnValue = command.ExecuteNonQuery();
  
          if (localConnection && unitOfWork.State == State.ConnectionOpen)
          {
              unitOfWork.CloseConnection();
          }
  
          return returnValue;
      }
  
      /// <summary>
      ///     Executes the reader to contract.
      /// </summary>
      public static TResultContractType ExecuteReaderToContract<TResultContractType>(this IUnitOfWork unitOfWork, string methodFullPath, SqlInfo sqlInfo, Action<IDataReader, TResultContractType> readContract) where TResultContractType : new()
      {
          var localConnection = false;
  
          var command = InitializeCommand(unitOfWork, sqlInfo.CommandText, ref localConnection);
  
          AddParameters(command, sqlInfo);
  
          var reader = command.ExecuteReader();
  
          var dataContract = default(TResultContractType);
  
          while (reader.Read())
          {
              dataContract = new TResultContractType();
  
              readContract(reader, dataContract);
  
              break;
          }
  
          reader.Close();
  
          if (localConnection && unitOfWork.State == State.ConnectionOpen)
          {
              unitOfWork.CloseConnection();
          }
  
          return dataContract;
      }
  
      /// <summary>
      ///     Executes the reader to list.
      /// </summary>
      public static List<TResultContractType> ExecuteReaderToList<TResultContractType>(this IUnitOfWork unitOfWork, string methodFullPath, SqlInfo sqlInfo, Action<IDataReader, TResultContractType> readContract) where TResultContractType : new()
      {
          var localConnection = false;
  
          var command = InitializeCommand(unitOfWork, sqlInfo.CommandText, ref localConnection);
  
          AddParameters(command, sqlInfo);
  
          var reader = command.ExecuteReader();
  
          var returnValue = reader.ReadToList(readContract);
  
          if (localConnection && unitOfWork.State == State.ConnectionOpen)
          {
              unitOfWork.CloseConnection();
          }
  
          return returnValue;
      }
  
      /// <summary>
      ///     Executes the scalar.
      /// </summary>
      public static TReturnValueType ExecuteScalar<TReturnValueType>(this IUnitOfWork unitOfWork, string methodFullPath, SqlInfo sqlInfo)
      {
          var localConnection = false;
  
          var command = InitializeCommand(unitOfWork, sqlInfo.CommandText, ref localConnection);
  
          AddParameters(command, sqlInfo);
  
          var returnValue = (TReturnValueType) command.ExecuteScalar();
  
          if (localConnection && unitOfWork.State == State.ConnectionOpen)
          {
              unitOfWork.CloseConnection();
          }
  
          return returnValue;
      }
      #endregion
  
      #region Methods
      /// <summary>
      ///     Adds the parameters.
      /// </summary>
      static void AddParameters(SqlCommand command, SqlInfo sqlInfo)
      {
          if (sqlInfo.Parameters == null)
          {
              return;
          }
  
          foreach (var parameter in sqlInfo.Parameters)
          {
              command.Parameters.Add(parameter);
          }
      }
  
      /// <summary>
      ///     Initializes the command.
      /// </summary>
      static SqlCommand InitializeCommand(IUnitOfWork unitOfWork, string commandText, ref bool localConnection)
      {
          localConnection = false;
  
          var command = new SqlCommand(commandText);
  
          if (unitOfWork.IsDistributed)
          {
              if (null == unitOfWork.ConnectionObject)
              {
                  unitOfWork.OpenConnection();
              }
  
              command.Connection = (SqlConnection) unitOfWork.ConnectionObject;
          }
          else
          {
              localConnection = null == unitOfWork.TransactionObject
                                  || null == unitOfWork.ConnectionObject
                                  || ((SqlConnection) unitOfWork.ConnectionObject).State == ConnectionState.Closed;
  
              if (localConnection)
              {
                  unitOfWork.OpenConnection();
              }
              else
              {
                  var transactionObject = unitOfWork.TransactionObject as IDbTransaction;
                  command.Transaction = (SqlTransaction) transactionObject;
              }
  
              command.Connection = (SqlConnection) unitOfWork.ConnectionObject;
          }
  
          return command;
      }
  
      /// <summary>
      ///     Readers to list.
      /// </summary>
      static List<TContractType> ReadToList<TContractType>(this IDataReader reader, Action<IDataReader, TContractType> ReadContract) where TContractType : new()
      {
          var listOfDataContract = new List<TContractType>();
  
          while (reader.Read())
          {
              var dataContract = new TContractType();
  
              ReadContract(reader, dataContract);
  
              listOfDataContract.Add(dataContract);
          }
  
          reader.Close();
  
          return listOfDataContract;
      }
      #endregion
  }