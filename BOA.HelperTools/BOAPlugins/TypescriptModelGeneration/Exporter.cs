using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using BOA.Common.Helpers;
using BOAPlugins.Utility;
using Mono.Cecil;

namespace BOAPlugins.TypescriptModelGeneration
{
    public class Exporter
    {
        #region Public Methods
        public static ExportData Export(string autoGeneratedModelsConfig_JsonFilePath)
        {
            var data = JsonHelper.Deserialize<ExportData>(File.ReadAllText(autoGeneratedModelsConfig_JsonFilePath));
            Export(data);
            return data;
        }

        public static string GetTypeNameInContainerNamespace(string typeFullName, string containerNamespace)
        {
            while (true)
            {
                var prefix = containerNamespace + ".";
                if (typeFullName.StartsWith(prefix))
                {
                    return typeFullName.RemoveFromStart(prefix);
                }

                var packages = containerNamespace.Split('.');
                if (packages.Length <= 1)
                {
                    return typeFullName;
                }

                var items = new List<string>();
                for (var i = 0; i < packages.Length - 1; i++)
                {
                    items.Add(packages[i]);
                }

                containerNamespace = string.Join(".", items);
            }
        }
        #endregion

        #region Methods
        static void Export(ExportData data)
        {
            var sb = new PaddedStringBuilder();

            var requestTypeFullNames = new List<string>();

            var typeDefinitions = new List<TypeDefinition>();

            foreach (var info in data.ExportInfoList)
            {
                var assemblyDefinition = AssemblyDefinition.ReadAssembly(@"d:\boa\server\bin\" + info.Assembly);
                if (assemblyDefinition == null)
                {
                    data.ErrorMessage = "AssemblyNotFound:" + info.Assembly;
                    return;
                }

                foreach (var className in info.ExportClassNames)
                {
                    var typeDefinition = assemblyDefinition.FindType(className);

                    if (typeDefinition == null)
                    {
                        data.ErrorMessage = "typeDefinitionNotFound:" + className;
                        return;
                    }

                    if (className.EndsWith("Request"))
                    {
                        requestTypeFullNames.Add(className);
                    }

                    typeDefinitions.Add(typeDefinition);
                }
            }

            var groupBy = typeDefinitions.GroupBy(x => x.Namespace, p => p);
            foreach (var ns in groupBy)
            {
                sb.AppendLine($"namespace {ns.Key}");
                sb.AppendLine("{");
                sb.PaddingCount++;

                var types = typeDefinitions.Where(t => t.Namespace == ns.Key);
                foreach (var typeDefinition in types)
                {
                    GenerateType(typeDefinition, sb);
                }

                sb.PaddingCount--;
                sb.AppendLine("}");
            }

            data.GeneratedTSCode = sb.ToString();

            data.RequestTypeFullNames = requestTypeFullNames.Distinct().ToList();

            data.TypeDefinitions = typeDefinitions;

            data.AutoGeneratedCodesInUtilDirectory = GetTSXCodeFor_AutoGeneratedCodesInUtilDirectory(data);
        }

        static void GenerateType(TypeDefinition typeDefinition, PaddedStringBuilder sb)
        {
            if (typeDefinition.IsEnum)
            {
                sb.AppendLine($"export enum {typeDefinition.Name}");
            }
            else
            {
                var extends = " extends ";
                if (typeDefinition.BaseType.FullName == typeof(object).FullName)
                {
                    extends = "";
                }
                else
                {
                    extends += GetTypeNameInContainerNamespace(typeDefinition.BaseType.FullName, typeDefinition.Namespace);
                }

                sb.AppendLine($"export interface {typeDefinition.Name}" + extends);
            }

            sb.AppendLine("{");
            sb.PaddingCount++;

            if (typeDefinition.IsEnum)
            {
                var fieldDeclarations = new List<string>();
                foreach (var field in typeDefinition.Fields.Where(f => f.Name != "value__"))
                {
                    fieldDeclarations.Add($"{field.Name} = {field.Constant}");
                }

                for (var i = 0; i < fieldDeclarations.Count; i++)
                {
                    var declaration = fieldDeclarations[i];

                    if (i < fieldDeclarations.Count - 1)
                    {
                        sb.AppendLine(declaration + ",");
                    }
                    else
                    {
                        sb.AppendLine(declaration);
                    }
                }
            }
            else
            {
                foreach (var propertyDefinition in typeDefinition.Properties.Where(p=>!IsImplicitDefinition(p)))
                {
                    var typeName = GetTSTypeName(propertyDefinition.PropertyType, typeDefinition.Namespace);

                    var name = TypescriptNaming.GetResolvedPropertyName(propertyDefinition.Name);

                    // if (IsNullableType(propertyDefinition.DeclaringType))
                    {
                        name += "?";
                    }
                    

                    sb.AppendLine($"{name} : {typeName};");
                }
            }

            sb.PaddingCount--;
            sb.AppendLine("}");
        }

        

        static bool IsImplicitDefinition(PropertyDefinition propertyDefinition)
        {
            if (propertyDefinition.PropertyType.FullName=="System.Runtime.Serialization.ExtensionDataObject")
            {
                return true;
            }

            return propertyDefinition.Name.Contains(".");
        }

        static string GenerateTypeProperties(TypeDefinition typeDefinition)
        {
            var sb = new PaddedStringBuilder();

            var className = typeDefinition.FullName.Replace(".", "_") + "_Property";

            sb.AppendLine($"export class {className}");
            sb.AppendLine("{");
            sb.PaddingCount++;

            var fieldNames = new List<string>();

            if (typeDefinition.IsEnum)
            {
                foreach (var field in typeDefinition.Fields.Where(f => f.Name != "value__"))
                {
                    fieldNames.Add(field.Name);
                }
            }
            else
            {
                foreach (var propertyDefinition in typeDefinition.Properties.Where(p=>!IsImplicitDefinition(p)))
                {
                    var name = TypescriptNaming.GetResolvedPropertyName(propertyDefinition.Name);
                    fieldNames.Add(name);
                }
            }

            foreach (var fieldName in fieldNames)
            {
                var propertyName = fieldName;
                if (propertyName == "name")
                {
                    propertyName = "Name";
                }

                sb.AppendLine($"static readonly {propertyName} = \"{fieldName}\";");
            }

            sb.PaddingCount--;
            sb.AppendLine("}");

            return sb.ToString();
        }

        static string GetTSTypeName(TypeReference typeReference, string containerNamespace)
        {
            if (IsNullableType(typeReference))
            {
                return GetTSTypeName(((GenericInstanceType) typeReference).GenericArguments[0], containerNamespace);
            }

            if (typeReference.FullName == "System.String")
            {
                return "string";
            }

            if (typeReference.FullName == typeof(short).FullName ||
                typeReference.FullName == typeof(int).FullName ||
                typeReference.FullName == typeof(byte).FullName ||
                typeReference.FullName == typeof(sbyte).FullName ||
                typeReference.FullName == typeof(short).FullName ||
                typeReference.FullName == typeof(ushort).FullName ||
                typeReference.FullName == typeof(double).FullName ||
                typeReference.FullName == typeof(float).FullName ||
                typeReference.FullName == typeof(decimal).FullName ||
                typeReference.FullName == typeof(long).FullName)

            {
                return "number";
            }

            if (typeReference.FullName == "System.DateTime")
            {
                return "Date";
            }

            if (typeReference.FullName == "System.Boolean")
            {
                return "boolean";
            }

            if (typeReference.FullName == "System.Object")
            {
                return "any";
            }

            if (typeReference.IsGenericInstance)
            {
                var genericInstanceType = (GenericInstanceType) typeReference;

                var isArrayType =
                    genericInstanceType.GenericArguments.Count == 1 &&
                    (
                        typeReference.Name == "Collection`1" ||
                        typeReference.Name == "List`1" ||
                        typeReference.Name == "IReadOnlyCollection`1" ||
                        typeReference.Name == "IReadOnlyList`1"
                    );

                if (isArrayType)
                {
                    var arrayType = genericInstanceType.GenericArguments[0];
                    return GetTSTypeName(arrayType, containerNamespace) + "[]";
                }
            }

            return GetTypeNameInContainerNamespace(typeReference.FullName, containerNamespace);
        }

        static string GetTSXCodeFor_AutoGeneratedCodesInUtilDirectory(ExportData data)
        {
            var requestTypeFullNames = data.RequestTypeFullNames;

            var sb = new PaddedStringBuilder();

            foreach (var requestTypeFullName in requestTypeFullNames)
            {
                var namespaceName = requestTypeFullName.Substring(0, requestTypeFullName.LastIndexOf('.')).Replace(".Types.", ".Orchestration.");

                var assemblyDefinition = AssemblyDefinition.ReadAssembly(@"d:\boa\server\bin\" + namespaceName + ".dll");
                if (assemblyDefinition == null)
                {
                    continue;
                }

                var orchestrationClassFullName = requestTypeFullName.RemoveFromEnd("Request").Replace(".Types.", ".Orchestration.");

                var orchestrationDefinition = assemblyDefinition.FindType(orchestrationClassFullName);
                if (orchestrationDefinition == null)
                {
                    continue;
                }

                var methodNames = orchestrationDefinition.Methods.Where(md => IsOrchestrationMethod(md, requestTypeFullName)).Select(md => md.Name).ToList();

                if (methodNames.Any())
                {
                    var className = requestTypeFullName.RemoveFromEnd("Request").Replace(".", "_") + "_OrchestrationMethod";

                    sb.AppendLine(string.Empty);
                    sb.AppendLine($"export class {className}");
                    sb.AppendLine("{");
                    sb.PaddingCount++;

                    foreach (var name in methodNames)
                    {
                        sb.AppendLine($"static readonly {name} = \"{name}\";");
                    }

                    sb.PaddingCount--;
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
            foreach (var requestTypeFullName in requestTypeFullNames)
            {
                sb.AppendLine($"export const {requestTypeFullName.Replace(".", "_") + "_FullName"} = \"{requestTypeFullName}\";");
            }

            foreach (var typeDefinition in data.TypeDefinitions)
            {
                sb.AppendLine();
                sb.AppendLine(GenerateTypeProperties(typeDefinition));
            }

            return sb.ToString();
        }

        static bool IsNullableType(TypeReference typeReference)
        {
            return typeReference.Name == "Nullable`1" && typeReference.IsGenericInstance;
        }

        static bool IsOrchestrationMethod(MethodDefinition m, string requestTypeFullName)
        {
            return m.Parameters.Count == 2 && m.IsPublic && m.Parameters[0].ParameterType.FullName == requestTypeFullName &&
                   m.Parameters[1].ParameterType.FullName == "BOA.Base.ObjectHelper";
        }
        #endregion
    }
}